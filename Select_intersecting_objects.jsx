#target Illustrator /*   Selects all paths who's bounding box overlaps with the geometry of the current selection   SelectObjectsOnActiveArtboard method of overlap detection found here:         http://forums.adobe.com/thread/789516   DOES NOT WORK FOR COMPOUND PATHS!   You must manually convert compound paths to single paths before running this script or   you will not be pleased with the selection.   Copyright 2012 Jay Cox*//* TODO: prevent running on illustrator versions prior to CS5 *//* TODO: Detect compound paths in the selection and warn the user. */var doc = app.activeDocument;var items_to_select = []; if (doc.selection.length == 0){    alert("You must select at least 1 object to run this script");     exit(1);}doc.artboards.add(doc.selection[0].visibleBounds);doc.artboards.setActiveArtboardIndex( doc.artboards.length -1);selection_bounds = get_bounding_box_of_objects(doc.selection);artboard = doc.artboards[doc.artboards.length -1];var selected_indexes = get_indexes_of_selected(doc.pathItems);for (var i=0; i<doc.pathItems.length; i++)    {        var current_object = doc.pathItems[i];        var bounds = current_object.visibleBounds;        if (current_object.locked || current_object.hidden)            continue;                    if (!rects_overlap(bounds, selection_bounds))            continue;        scale_rect_to_minimum_artboard_size(bounds);        try        {            artboard.artboardRect = bounds;            doc.selectObjectsOnActiveArtboard();        }        catch(e)        {            //alert("Got an error " + e );            continue;        }        for (var j =0; j < selected_indexes.length; j++)        {            if (selected_indexes[j] == i)                break;            if (doc.pathItems[selected_indexes[j]].selected)            {                items_to_select.push(i);                break;            }        }     }doc.selection = null; /* deselect all */for (var index = 0; index < items_to_select.length; index++){    doc.pathItems[items_to_select[index]].selected = true;}doc.artboards.remove(doc.artboards.length -1);//alert("the selected object intersects with " + items_to_select.length + " other objects");function get_bounding_box_of_objects(objects){    box = objects[0].visibleBounds;    if (box[0] > box[2])    {        var tmp = box[0];        box[0] = box[2];        box[2] = tmp;    }    if (box[1] > box[3])    {        var tmp = box[1];        box[1] = box[3];        box[3] = tmp;    }    for (var i = 1; i < objects.length; i++)    {        obox = objects[i].visibleBounds;        if (obox[0] < box[0])            box[0] = obox[0];        if (obox[2] < box[0])            box[0] = obox[2];         if (obox[1] < box[1])            box[1] = obox[1];        if (obox[3] < box[1])            box[1] = obox[3];        if (obox[0] > box[2])            box[2] = obox[0];        if (obox[2] > box[2])            box[2] = obox[2];         if (obox[1] > box[3])            box[3] = obox[1];        if (obox[3] > box[3])            box[3] = obox[3];     }    return box;}function get_indexes_of_selected(objects){    var indexes = [];    for (i = 0; i < objects.length; i++)    {        if (objects[i].selected)        {            indexes.push(i);            //dump_object_alert(objects[i]);        }    }    return indexes;}function dump_object_alert(obj){    var expanded = '';    for (i in obj)    {        try{        expanded += i + ": " + obj[i] + "\n";        }        catch(e)        {            expanded += i + ": <exception caught>\n";        }    }    alert (expanded); }function rects_overlap(a, b){     if ((a[0] > b[0] != a[0] > b[2]) ||        (a[2] > b[0] != a[2] > b[2]))        if ((a[1] > b[1] != a[1] > b[3]) ||            (a[3] > b[1] != a[3] > b[3]))            return true;    // check if a competely encloses b    if ((b[0] > a[0] != b[0] > a[2]) &&        (b[1] > a[1] != b[1] > a[3]))        return true;    return false;}/* Makes sure the rect is atleast 1pt wide and tall (the minimum artboard size) */function scale_rect_to_minimum_artboard_size(r) {      if (Math.abs(r[0] - r[2]) < 1)      {          var center = (r[0] + r[2]) /2.0;          r[0] = center -.5;          r[2] = center +.5;      }      if (Math.abs(r[1] - r[3]) < 1)      {          var center = (r[1] + r[3]) /2.0;          r[1] = center -.5;          r[3] = center +.5;      } }